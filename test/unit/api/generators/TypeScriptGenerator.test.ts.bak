/**
 * Comprehensive Tests for TypeScriptGenerator
 * 
 * Tests the new TypeScriptGenerator built on BaseGenerator architecture.
 * Ensures proper integration with TypeMapper, TemplateEngine, and FileManager.
 */

import { describe, it, expect, beforeEach } from 'bun:test';
import { TypeScriptGenerator, type TypeScriptGeneratorOptions } from '../../../../src/api/generators/TypeScriptGenerator';
import type { TypeSchema } from '../../../../src/typeschema';
import { createLogger } from '../../../../src/utils/codegen-logger';

// Mock TypeSchema for testing
const createMockSchema = (overrides: Partial<TypeSchema> = {}): TypeSchema => ({
	identifier: {
		name: 'Patient',
		package: 'hl7.fhir.r4.core',
		version: '4.0.1',
		kind: 'resource',
		url: 'http://hl7.org/fhir/Patient'
	},
	description: 'Demographics and other administrative information about a person',
	kind: 'complex-type',
	baseType: 'DomainResource',
	elements: {
		resourceType: {
			name: 'resourceType',
			min: 1,
			max: 1,
			type: [{ code: 'code' }],
			binding: {
				strength: 'required',
				valueSet: 'resource-types'
			}
		},
		identifier: {
			name: 'identifier',
			min: 0,
			max: '*',
			type: [{ code: 'Identifier' }],
			description: 'An identifier for this patient'
		},
		name: {
			name: 'name',
			min: 0,
			max: '*',
			type: [{ code: 'HumanName' }],
			description: 'A name associated with the patient'
		},
		birthDate: {
			name: 'birthDate',
			min: 0,
			max: 1,
			type: [{ code: 'date' }],
			description: 'The birth date for the patient'
		}
	},
	...overrides
});

// Mock profile schema
const createMockProfileSchema = (overrides: Partial<TypeSchema> = {}): TypeSchema => ({
	identifier: {
		name: 'USCorePatient',
		package: 'us.core',
		version: '3.1.1',
		kind: 'profile',
		url: 'http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient'
	},
	description: 'US Core Patient Profile',
	kind: 'complex-type',
	baseType: 'Patient',
	elements: {
		identifier: {
			name: 'identifier',
			min: 1,
			max: '*',
			type: [{ code: 'Identifier' }],
			description: 'Patient identifier - required in US Core'
		},
		name: {
			name: 'name',
			min: 1,
			max: '*',
			type: [{ code: 'HumanName' }],
			description: 'Patient name - required in US Core'
		}
	},
	constraints: [
		{
			name: 'RequiredIdentifier',
			description: 'Patient must have at least one identifier',
			constraintType: 'string'
		}
	],
	...overrides
});

// Test options
const defaultOptions: TypeScriptGeneratorOptions = {
	outputDir: '/tmp/test-output',
	logger: createLogger({ prefix: 'Test', verbose: false }),
	overwrite: true,
	validate: true
};

describe('TypeScriptGenerator', () => {
	let generator: TypeScriptGenerator;
	
	beforeEach(() => {
		generator = new TypeScriptGenerator(defaultOptions);
	});

	// ===========================================
	// Constructor and Initialization Tests
	// ===========================================

	describe('constructor and initialization', () => {
		it('should initialize with default options', () => {
			const gen = new TypeScriptGenerator(defaultOptions);
			expect(gen).toBeInstanceOf(TypeScriptGenerator);
		});

		it('should merge TypeScript-specific defaults', () => {
			const gen = new TypeScriptGenerator({
				...defaultOptions,
				moduleFormat: 'cjs',
				generateIndex: false
			});
			
			expect(gen).toBeInstanceOf(TypeScriptGenerator);
		});

		it('should initialize TypeMapper correctly', () => {
			// Test that the generator creates a TypeScriptTypeMapper
			expect(generator).toBeInstanceOf(TypeScriptGenerator);
		});

		it('should initialize TemplateEngine correctly', () => {
			// Test that the generator creates a HandlebarsTemplateEngine
			expect(generator).toBeInstanceOf(TypeScriptGenerator);
		});
	});

	// ===========================================
	// BaseGenerator Implementation Tests
	// ===========================================

	describe('BaseGenerator implementation', () => {
		it('should return correct language name', () => {
			// Test protected method via public API
			expect(generator).toBeInstanceOf(TypeScriptGenerator);
		});

		it('should return correct file extension', () => {
			// Test that generated files have .ts extension
			expect(generator).toBeInstanceOf(TypeScriptGenerator);
		});
	});

	// ===========================================
	// Schema Processing Tests
	// ===========================================

	describe('schema processing', () => {
		it('should transform basic resource schema', async () => {
			const schema = createMockSchema();
			// Use build() instead of generate() to avoid file writing issues
			const results = await generator.build([schema]);
			
			expect(results).toBeInstanceOf(Array);
			expect(results.length).toBeGreaterThan(0);
			
			const result = results[0];
			expect(result.filename).toBe('Patient.ts');
			expect(result.content).toContain('export interface Patient');
			expect(result.exports).toContain('Patient');
		});

		it('should skip unsupported schema types', async () => {
			const valueSetSchema = createMockSchema({
				identifier: { ...createMockSchema().identifier, kind: 'value-set' }
			});
			
			const results = await generator.generate([valueSetSchema]);
			expect(results.length).toBe(1); // Only index file
		});

		it('should process profile schemas when enabled', async () => {
			const gen = new TypeScriptGenerator({
				...defaultOptions,
				includeProfiles: true
			});
			
			const profileSchema = createMockProfileSchema();
			const results = await gen.generate([profileSchema]);
			
			expect(results.length).toBeGreaterThan(0);
			expect(results.some(r => r.content.includes('USCorePatient'))).toBe(true);
		});

		it('should skip profile schemas when disabled', async () => {
			const gen = new TypeScriptGenerator({
				...defaultOptions,
				includeProfiles: false
			});
			
			const profileSchema = createMockProfileSchema();
			const results = await gen.generate([profileSchema]);
			
			// Should only generate index file
			expect(results.length).toBe(1);
			expect(results[0].filename).toBe('index.ts');
		});
	});

	// ===========================================
	// Template Selection Tests
	// ===========================================

	describe('template selection', () => {
		it('should use interface template for basic resources', async () => {
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			
			const result = results.find(r => r.filename === 'Patient.ts');
			expect(result?.content).toContain('export interface Patient');
		});

		it('should use profile template for profiles', async () => {
			const gen = new TypeScriptGenerator({
				...defaultOptions,
				includeProfiles: true
			});
			
			const profileSchema = createMockProfileSchema();
			const results = await gen.generate([profileSchema]);
			
			const result = results.find(r => r.filename.includes('USCorePatient'));
			expect(result?.content).toContain('extends Patient');
		});

		it('should use interface-with-enums template for schemas with enums', async () => {
			const schemaWithEnum = createMockSchema({
				elements: {
					...createMockSchema().elements,
					status: {
						name: 'status',
						min: 1,
						max: 1,
						type: [{ code: 'code' }],
						binding: {
							strength: 'required',
							valueSet: 'patient-status'
						}
					}
				}
			});
			
			const results = await generator.generate([schemaWithEnum]);
			
			// Should detect enum and use appropriate template
			expect(results.length).toBeGreaterThan(0);
		});
	});

	// ===========================================
	// Field Processing Tests
	// ===========================================

	describe('field processing', () => {
		it('should process required fields correctly', async () => {
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			
			const result = results.find(r => r.filename === 'Patient.ts');
			expect(result?.content).toContain('resourceType:'); // Required field (no ?)
		});

		it('should process optional fields correctly', async () => {
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			
			const result = results.find(r => r.filename === 'Patient.ts');
			expect(result?.content).toContain('birthDate?:'); // Optional field (with ?)
		});

		it('should process array fields correctly', async () => {
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			
			const result = results.find(r => r.filename === 'Patient.ts');
			expect(result?.content).toContain('identifier?:'); // Array field
			expect(result?.content).toContain('[]'); // Array notation
		});

		it('should format field names correctly', async () => {
			const schema = createMockSchema({
				elements: {
					'birth-date': {
						name: 'birth-date',
						min: 0,
						max: 1,
						type: [{ code: 'date' }],
						description: 'Birth date with hyphen'
					}
				}
			});
			
			const results = await generator.generate([schema]);
			
			const result = results.find(r => r.filename === 'Patient.ts');
			expect(result?.content).toContain('birthDate'); // camelCase conversion
		});
	});

	// ===========================================
	// Import/Export Management Tests
	// ===========================================

	describe('import/export management', () => {
		it('should extract imports from generated content', async () => {
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			
			// Should handle any imports needed for complex types
			expect(results).toBeInstanceOf(Array);
		});

		it('should extract exports from generated content', async () => {
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			
			const result = results.find(r => r.filename === 'Patient.ts');
			expect(result?.exports).toContain('Patient');
		});

		it('should handle complex type references', async () => {
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			
			// Should handle references to other types like Identifier, HumanName
			expect(results.length).toBeGreaterThan(0);
		});
	});

	// ===========================================
	// Index File Generation Tests
	// ===========================================

	describe('index file generation', () => {
		it('should generate main index file by default', async () => {
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			
			const indexFile = results.find(r => r.filename === 'index.ts');
			expect(indexFile).toBeDefined();
			expect(indexFile?.content).toContain('export');
		});

		it('should skip index file when disabled', async () => {
			const gen = new TypeScriptGenerator({
				...defaultOptions,
				generateIndex: false
			});
			
			const schema = createMockSchema();
			const results = await gen.generate([schema]);
			
			const indexFile = results.find(r => r.filename === 'index.ts');
			expect(indexFile).toBeUndefined();
		});

		it('should group exports by category', async () => {
			const resourceSchema = createMockSchema();
			const results = await generator.generate([resourceSchema]);
			
			const indexFile = results.find(r => r.filename === 'index.ts');
			expect(indexFile?.content).toBeDefined();
		});

		it('should generate profile index files when profiles are included', async () => {
			const gen = new TypeScriptGenerator({
				...defaultOptions,
				includeProfiles: true
			});
			
			const profileSchema = createMockProfileSchema();
			const results = await gen.generate([profileSchema]);
			
			// Should include profile-specific index files
			expect(results.some(r => r.filename.includes('profiles'))).toBe(true);
		});
	});

	// ===========================================
	// Configuration Options Tests
	// ===========================================

	describe('configuration options', () => {
		it('should respect moduleFormat option', async () => {
			const esmGen = new TypeScriptGenerator({
				...defaultOptions,
				moduleFormat: 'esm'
			});
			
			const cjsGen = new TypeScriptGenerator({
				...defaultOptions,
				moduleFormat: 'cjs'
			});
			
			expect(esmGen).toBeInstanceOf(TypeScriptGenerator);
			expect(cjsGen).toBeInstanceOf(TypeScriptGenerator);
		});

		it('should respect includeDocuments option', async () => {
			const withDocs = new TypeScriptGenerator({
				...defaultOptions,
				includeDocuments: true
			});
			
			const withoutDocs = new TypeScriptGenerator({
				...defaultOptions,
				includeDocuments: false
			});
			
			const schema = createMockSchema();
			
			const resultsWithDocs = await withDocs.generate([schema]);
			const resultsWithoutDocs = await withoutDocs.generate([schema]);
			
			const fileWithDocs = resultsWithDocs.find(r => r.filename === 'Patient.ts');
			const fileWithoutDocs = resultsWithoutDocs.find(r => r.filename === 'Patient.ts');
			
			expect(fileWithDocs?.content).toContain('/**');
			expect(fileWithoutDocs?.content).not.toContain('/**');
		});

		it('should respect namingConvention option', async () => {
			const pascalGen = new TypeScriptGenerator({
				...defaultOptions,
				namingConvention: 'PascalCase'
			});
			
			const camelGen = new TypeScriptGenerator({
				...defaultOptions,
				namingConvention: 'camelCase'
			});
			
			expect(pascalGen).toBeInstanceOf(TypeScriptGenerator);
			expect(camelGen).toBeInstanceOf(TypeScriptGenerator);
		});
	});

	// ===========================================
	// Error Handling Tests
	// ===========================================

	describe('error handling', () => {
		it('should handle invalid schemas gracefully', async () => {
			const invalidSchema = {
				...createMockSchema(),
				elements: undefined
			} as any;
			
			const results = await generator.generate([invalidSchema]);
			expect(results).toBeInstanceOf(Array);
		});

		it('should handle template errors gracefully', async () => {
			// This would require mocking template engine errors
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			expect(results).toBeInstanceOf(Array);
		});

		it('should handle file operation errors gracefully', async () => {
			const gen = new TypeScriptGenerator({
				...defaultOptions,
				outputDir: '/invalid/path/that/cannot/be/created'
			});
			
			const schema = createMockSchema();
			
			// Should not throw, but handle gracefully
			try {
				const results = await gen.generate([schema]);
				expect(results).toBeInstanceOf(Array);
			} catch (error) {
				// Expected in some cases due to invalid path
				expect(error).toBeDefined();
			}
		});
	});

	// ===========================================
	// Performance Tests
	// ===========================================

	describe('performance', () => {
		it('should handle multiple schemas efficiently', async () => {
			const schemas = Array.from({ length: 10 }, (_, i) => 
				createMockSchema({
					identifier: {
						...createMockSchema().identifier,
						name: `TestResource${i}`
					}
				})
			);
			
			const startTime = performance.now();
			const results = await generator.generate(schemas);
			const duration = performance.now() - startTime;
			
			expect(results.length).toBeGreaterThan(schemas.length); // Includes index
			expect(duration).toBeLessThan(5000); // Should complete within 5 seconds
		});

		it('should handle large schemas efficiently', async () => {
			// Create a schema with many fields
			const largeSchema = createMockSchema({
				elements: Object.fromEntries(
					Array.from({ length: 50 }, (_, i) => [
						`field${i}`,
						{
							name: `field${i}`,
							min: 0,
							max: 1,
							type: [{ code: 'string' }],
							description: `Test field ${i}`
						}
					])
				)
			});
			
			const startTime = performance.now();
			const results = await generator.generate([largeSchema]);
			const duration = performance.now() - startTime;
			
			expect(results.length).toBeGreaterThan(0);
			expect(duration).toBeLessThan(2000); // Should complete within 2 seconds
		});
	});

	// ===========================================
	// Integration Tests
	// ===========================================

	describe('integration with base architecture', () => {
		it('should use TypeMapper for type conversion', async () => {
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			
			const result = results.find(r => r.filename === 'Patient.ts');
			// Should convert FHIR types to TypeScript types
			expect(result?.content).toContain('string'); // date -> string
		});

		it('should use TemplateEngine for content generation', async () => {
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			
			const result = results.find(r => r.filename === 'Patient.ts');
			// Should use Handlebars templates
			expect(result?.content).toContain('export interface');
		});

		it('should use FileManager for output management', async () => {
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			
			// Should produce GeneratedFile objects
			for (const result of results) {
				expect(result).toHaveProperty('path');
				expect(result).toHaveProperty('filename');
				expect(result).toHaveProperty('content');
				expect(result).toHaveProperty('exports');
				expect(result).toHaveProperty('size');
				expect(result).toHaveProperty('timestamp');
			}
		});
	});

	// ===========================================
	// Backward Compatibility Tests
	// ===========================================

	describe('backward compatibility', () => {
		it('should generate same structure as legacy generator', async () => {
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			
			// Should maintain expected file structure
			expect(results.some(r => r.filename === 'Patient.ts')).toBe(true);
			expect(results.some(r => r.filename === 'index.ts')).toBe(true);
		});

		it('should maintain expected TypeScript interface format', async () => {
			const schema = createMockSchema();
			const results = await generator.generate([schema]);
			
			const result = results.find(r => r.filename === 'Patient.ts');
			expect(result?.content).toMatch(/export interface Patient \{[\s\S]*\}/);
		});
	});
});

// ===========================================
// Utility Functions for Testing
// ===========================================

/**
 * Helper to validate generated TypeScript content
 */
function validateTypeScriptContent(content: string): boolean {
	// Basic validation - could be enhanced with actual TypeScript compilation
	return content.includes('export') && 
	       content.includes('interface') &&
	       content.includes('{') &&
	       content.includes('}');
}

/**
 * Helper to extract interface names from generated content
 */
function extractInterfaceNames(content: string): string[] {
	const matches = content.match(/export interface (\w+)/g) || [];
	return matches.map(match => match.replace('export interface ', ''));
}

/**
 * Helper to count generated files by type
 */
function countFilesByType(results: { filename: string }[]): Record<string, number> {
	const counts: Record<string, number> = {
		interfaces: 0,
		index: 0,
		profiles: 0
	};
	
	for (const result of results) {
		if (result.filename === 'index.ts') {
			counts.index++;
		} else if (result.filename.includes('profile')) {
			counts.profiles++;
		} else {
			counts.interfaces++;
		}
	}
	
	return counts;
}