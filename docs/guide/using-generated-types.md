# Using Generated Types

This guide shows how to effectively use the TypeScript types generated by @atomic-ehr/type-schema in your applications.

## Understanding the Generated Structure

After running the generator, you'll have a well-organized type structure:

```
generated/
├── index.ts                 # Main entry point
├── types/
│   ├── primitives.ts       # FHIR primitive types
│   └── complex.ts          # Complex data types
└── resources/
    ├── Patient.ts          # Patient resource
    ├── Observation.ts      # Observation resource
    └── ...                 # All other FHIR resources
```

## Basic Usage

### Importing Types

```typescript
// Import specific resources
import { Patient, Observation, Encounter } from './generated';

// Import primitive types
import { dateTime, code, id } from './generated/types/primitives';

// Import complex types
import { HumanName, Address, CodeableConcept } from './generated/types/complex';

// Import everything
import * as FHIR from './generated';
```

### Creating Resources

```typescript
import { Patient, ContactPoint } from './generated';

const patient: Patient = {
  resourceType: 'Patient',
  id: 'patient-123',
  active: true,
  name: [{
    use: 'official',
    family: 'Smith',
    given: ['John', 'Michael'],
    prefix: ['Mr.']
  }],
  gender: 'male',
  birthDate: '1980-07-15',
  telecom: [{
    system: 'phone',
    value: '+1-555-123-4567',
    use: 'mobile',
    rank: 1
  }],
  address: [{
    use: 'home',
    type: 'physical',
    line: ['123 Main Street', 'Apt 4B'],
    city: 'Boston',
    state: 'MA',
    postalCode: '02115',
    country: 'USA'
  }]
};
```

## Type Safety Features

### IntelliSense Support

The generated types provide full IntelliSense support in VS Code and other TypeScript-aware editors:

```typescript
const observation: Observation = {
  resourceType: 'Observation',
  status: 'final', // IntelliSense shows: "registered" | "preliminary" | "final" | "amended" | ...
  code: {
    coding: [{
      system: 'http://loinc.org',
      code: '85354-9',
      display: 'Blood pressure panel'
    }]
  },
  // TypeScript will show all available fields with their types
};
```

### Type Checking

TypeScript will catch errors at compile time:

```typescript
const patient: Patient = {
  resourceType: 'Patient',
  gender: 'unknown', // ✅ Valid: "male" | "female" | "other" | "unknown"
  active: 'yes'      // ❌ Error: Type 'string' is not assignable to type 'boolean'
};
```

### Required vs Optional Fields

The types correctly distinguish between required and optional fields:

```typescript
const observation: Observation = {
  resourceType: 'Observation', // Required
  status: 'final',            // Required
  code: { /*...*/ },         // Required
  subject: { /*...*/ },      // Optional
  effectiveDateTime: '2024-01-15T10:30:00Z' // Optional
};
```

## Working with References

### Creating References

```typescript
import { Reference, Patient, Practitioner } from './generated';

const patientReference: Reference<Patient> = {
  reference: 'Patient/123',
  display: 'John Smith'
};

const practitionerReference: Reference<Practitioner> = {
  reference: 'Practitioner/dr-jones',
  type: 'Practitioner',
  display: 'Dr. Sarah Jones'
};
```

### Type-Safe Reference Resolution

```typescript
function resolvePatientReference(ref: Reference<Patient>): Promise<Patient> {
  // TypeScript knows this should return a Patient
  const id = ref.reference?.split('/')[1];
  return fetchPatient(id!);
}
```

## Advanced Patterns

### Type Guards

Create type guards for runtime type checking:

```typescript
import { ResourceTypeMap, AnyResource } from './generated';

function isPatient(resource: AnyResource): resource is Patient {
  return resource.resourceType === 'Patient';
}

function isValidResourceType(type: string): type is keyof typeof ResourceTypeMap {
  return type in ResourceTypeMap;
}

// Usage
const resource: AnyResource = await fetchResource();
if (isPatient(resource)) {
  // TypeScript knows this is a Patient
  console.log(resource.name?.[0]?.family);
}
```

### Generic Resource Handlers

```typescript
import { AnyResource, ResourceType } from './generated';

class FHIRClient {
  async create<T extends AnyResource>(resource: T): Promise<T> {
    const response = await fetch(`/fhir/${resource.resourceType}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/fhir+json' },
      body: JSON.stringify(resource)
    });
    return response.json();
  }

  async read<T extends AnyResource>(
    type: T['resourceType'],
    id: string
  ): Promise<T> {
    const response = await fetch(`/fhir/${type}/${id}`);
    return response.json();
  }
}

// Usage with full type safety
const client = new FHIRClient();
const patient = await client.read('Patient', '123'); // Returns Patient type
const obs = await client.create(observation);        // Returns Observation type
```

### Builders and Factories

Create type-safe builders:

```typescript
import { Patient, HumanName, ContactPoint } from './generated';

class PatientBuilder {
  private patient: Partial<Patient> = {
    resourceType: 'Patient'
  };

  withName(name: HumanName): this {
    if (!this.patient.name) {
      this.patient.name = [];
    }
    this.patient.name.push(name);
    return this;
  }

  withGender(gender: Patient['gender']): this {
    this.patient.gender = gender;
    return this;
  }

  withBirthDate(date: string): this {
    this.patient.birthDate = date;
    return this;
  }

  build(): Patient {
    if (!this.patient.resourceType) {
      throw new Error('ResourceType is required');
    }
    return this.patient as Patient;
  }
}

// Usage
const patient = new PatientBuilder()
  .withName({
    family: 'Smith',
    given: ['John']
  })
  .withGender('male')
  .withBirthDate('1980-01-01')
  .build();
```

## Working with Extensions

```typescript
import { Patient, Extension } from './generated';

interface PatientWithRace extends Patient {
  extension?: Array<Extension | RaceExtension>;
}

interface RaceExtension extends Extension {
  url: 'http://hl7.org/fhir/us/core/StructureDefinition/us-core-race';
  extension: Array<{
    url: 'ombCategory' | 'text';
    valueCoding?: {
      system: string;
      code: string;
      display: string;
    };
    valueString?: string;
  }>;
}

const patientWithRace: PatientWithRace = {
  resourceType: 'Patient',
  id: '123',
  extension: [{
    url: 'http://hl7.org/fhir/us/core/StructureDefinition/us-core-race',
    extension: [{
      url: 'ombCategory',
      valueCoding: {
        system: 'urn:oid:2.16.840.1.113883.6.238',
        code: '2106-3',
        display: 'White'
      }
    }, {
      url: 'text',
      valueString: 'White'
    }]
  }]
};
```

## Validation

While the types provide compile-time safety, you may want runtime validation:

```typescript
import { Patient } from './generated';

function validatePatient(data: unknown): data is Patient {
  if (typeof data !== 'object' || data === null) {
    return false;
  }
  
  const patient = data as Patient;
  
  // Check required fields
  if (patient.resourceType !== 'Patient') {
    return false;
  }
  
  // Check types
  if (patient.active !== undefined && typeof patient.active !== 'boolean') {
    return false;
  }
  
  if (patient.gender !== undefined && 
      !['male', 'female', 'other', 'unknown'].includes(patient.gender)) {
    return false;
  }
  
  return true;
}
```

## Integration with Libraries

### With React

```typescript
import React from 'react';
import { Patient, HumanName } from './generated';

interface PatientCardProps {
  patient: Patient;
}

const PatientCard: React.FC<PatientCardProps> = ({ patient }) => {
  const displayName = (name: HumanName): string => {
    const given = name.given?.join(' ') || '';
    const family = name.family || '';
    return `${given} ${family}`.trim();
  };

  return (
    <div className="patient-card">
      <h2>{patient.name?.map(displayName).join(', ')}</h2>
      <p>Gender: {patient.gender}</p>
      <p>Birth Date: {patient.birthDate}</p>
    </div>
  );
};
```

### With Form Libraries

```typescript
import { useForm } from 'react-hook-form';
import { Patient } from './generated';

function PatientForm() {
  const { register, handleSubmit } = useForm<Patient>({
    defaultValues: {
      resourceType: 'Patient',
      active: true
    }
  });

  const onSubmit = (data: Patient) => {
    console.log('Valid patient data:', data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('name.0.given.0')} placeholder="First name" />
      <input {...register('name.0.family')} placeholder="Last name" />
      <select {...register('gender')}>
        <option value="male">Male</option>
        <option value="female">Female</option>
        <option value="other">Other</option>
        <option value="unknown">Unknown</option>
      </select>
      <button type="submit">Save</button>
    </form>
  );
}
```

## Performance Tips

### Import Only What You Need

```typescript
// ✅ Good: Import specific types
import { Patient, Observation } from './generated';

// ❌ Avoid: Importing everything if not needed
import * as FHIR from './generated';
```

### Use Type-Only Imports

```typescript
// When you only need types, not runtime values
import type { Patient, Observation } from './generated';
```

### Lazy Loading

```typescript
// Dynamically import large resources
async function loadMedicationKnowledge() {
  const { MedicationKnowledge } = await import('./generated/resources/MedicationKnowledge');
  // Use MedicationKnowledge type
}
```

## Common Patterns

### Search Parameters

```typescript
interface SearchParams {
  [key: string]: string | string[] | undefined;
}

function searchPatients(params: SearchParams): Promise<Bundle<Patient>> {
  const searchParams = new URLSearchParams();
  
  Object.entries(params).forEach(([key, value]) => {
    if (value !== undefined) {
      if (Array.isArray(value)) {
        value.forEach(v => searchParams.append(key, v));
      } else {
        searchParams.append(key, value);
      }
    }
  });
  
  return fetch(`/fhir/Patient?${searchParams}`).then(r => r.json());
}

// Usage
const results = await searchPatients({
  name: 'Smith',
  gender: 'male',
  birthdate: ['ge2000-01-01', 'le2020-12-31']
});
```

### Bundle Operations

```typescript
import { Bundle, Patient, BundleEntry } from './generated';

function createTransactionBundle(patients: Patient[]): Bundle {
  return {
    resourceType: 'Bundle',
    type: 'transaction',
    entry: patients.map(patient => ({
      fullUrl: `urn:uuid:${crypto.randomUUID()}`,
      resource: patient,
      request: {
        method: 'POST',
        url: 'Patient'
      }
    }))
  };
}
```

## Next Steps

- Learn about [customizing code generation](./customization.md)
- Explore [best practices](./best-practices.md)
- See [integration examples](../examples/integration.md)
- Read about [troubleshooting common issues](./troubleshooting.md)