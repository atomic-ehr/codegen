# Generator Registry System

The Generator Registry System provides a centralized way to manage and discover code generators in the Atomic EHR Codegen project. It supports both built-in generators and external plugins, making the system extensible and modular.

## Overview

The registry system consists of several key components:

- **Generator Interface**: Defines the contract that all generators must implement
- **Generator Registry**: Central registry for managing generators
- **Plugin Loader**: Discovers and loads external generator plugins
- **Built-in Generators**: Pre-installed generators (like TypeScript)
- **CLI Integration**: Commands for listing and using generators

## Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   CLI Commands  │    │  Generator      │    │  Plugin Loader  │
│                 │    │  Registry       │    │                 │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ • generate      │───▶│ • register()    │◀───│ • discover()    │
│ • generators    │    │ • create()      │    │ • loadPlugins() │
│   - list        │    │ • list()        │    │ • validate()    │
│   - info        │    │ • validate()    │    └─────────────────┘
└─────────────────┘    └─────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │   Generators    │
                    │                 │
                    ├─────────────────┤
                    │ • TypeScript    │
                    │ • Custom Plugin │
                    │ • ...           │
                    └─────────────────┘
```

## Core Interfaces

### Generator Interface

All generators must implement the `Generator` interface:

```typescript
interface Generator {
  readonly name: string;
  readonly target: string;
  generate(): Promise<void>;
  validate?(): Promise<void>;
  cleanup?(): Promise<void>;
}
```

### Generator Metadata

Each generator has associated metadata:

```typescript
interface GeneratorMetadata {
  id: string;
  name: string;
  target: string;
  version: string;
  description: string;
  author?: string;
  supportedInputs?: string[];
  supportedOutputs?: string[];
  builtin: boolean;
  modulePath?: string;
  configSchema?: Record<string, unknown>;
}
```

## Using the Registry System

### CLI Usage

List available generators:
```bash
# List all generators
atomic-codegen generators list

# List generators for specific target
atomic-codegen generators list --target typescript

# List only built-in generators
atomic-codegen generators list --builtin

# Show detailed information
atomic-codegen generators list --verbose
```

Get detailed information about a generator:
```bash
atomic-codegen generators info typescript
```

Generate code using a registered generator:
```bash
atomic-codegen generate typescript -i schemas.ndjson -o ./generated
```

### Programmatic Usage

```typescript
import { defaultRegistry, ensureInitialized } from '@atomic-ehr/codegen';

// Initialize the registry system
await ensureInitialized();

// List available generators
const generators = defaultRegistry.list();
console.log('Available generators:', generators.map(g => g.id));

// Create a generator instance
const generator = await defaultRegistry.create('typescript', {
  outputDir: './generated',
  verbose: true,
});

// Use the generator
await generator.validate();
await generator.generate();
```

## Creating Custom Generators

### Basic Generator

Create a generator by extending `BaseGenerator`:

```typescript
import { BaseGenerator } from '@atomic-ehr/codegen';

class MyGenerator extends BaseGenerator {
  readonly name = "my-generator";
  readonly target = "my-target";

  async generate(): Promise<void> {
    // Create a file
    this.file("output.txt");
    
    // Add content
    this.line("Hello, World!");
    this.blank();
    this.line("Generated by MyGenerator");
    
    // Write files to disk
    await this.writeFiles();
  }
}
```

### Generator Plugin

Create a plugin by implementing the `GeneratorPlugin` interface:

```typescript
import type { GeneratorPlugin, GeneratorMetadata } from '@atomic-ehr/codegen';

// Generator metadata
export const metadata: GeneratorMetadata = {
  id: "my-plugin",
  name: "My Custom Generator",
  target: "custom",
  version: "1.0.0",
  description: "A custom generator plugin",
  builtin: false,
};

// Generator factory
export function createGenerator(options: GeneratorOptions): Generator {
  return new MyGenerator(options);
}

// Plugin export
export const plugin: GeneratorPlugin = {
  metadata,
  createGenerator,
};
```

### Plugin Discovery

The plugin loader automatically discovers plugins in these locations:

- `./plugins/` - Local plugins directory
- `./generators/` - Local generators directory
- `node_modules/@atomic-ehr/codegen-*` - Scoped packages
- `node_modules/codegen-*` - Generator packages

Plugin files must:
- Have `.js`, `.ts`, or `.mjs` extension
- Include "generator" or "plugin" in the filename
- Export either:
  - A `plugin` object with `GeneratorPlugin` interface
  - A default export implementing `GeneratorPlugin`
  - Named exports: `metadata` and `createGenerator`

## Configuration

### Registry Initialization

Configure the registry during initialization:

```typescript
import { initializeGeneratorSystem } from '@atomic-ehr/codegen';

await initializeGeneratorSystem({
  // Custom plugin directories
  pluginDirs: ['./my-plugins', './custom-generators'],
  
  // Whether to register built-in generators
  registerBuiltins: true,
  
  // Whether to load external plugins
  loadPlugins: true,
  
  // Whether to ignore plugin loading errors
  ignorePluginErrors: true,
  
  // Additional plugin search paths
  customPluginPaths: ['./vendor/generators'],
});
```

### Generator Options

All generators receive `GeneratorOptions`:

```typescript
interface GeneratorOptions {
  outputDir: string;
  verbose?: boolean;
  overwrite?: boolean;
  encoding?: BufferEncoding;
  format?: boolean;
  fileHeader?: string;
}
```

Custom generators can extend these options:

```typescript
interface MyGeneratorOptions extends GeneratorOptions {
  customOption?: string;
  enableFeature?: boolean;
}
```

## Testing

### Testing Utilities

The system provides comprehensive testing utilities:

```typescript
import { 
  runGeneratorTest, 
  createTestFixture,
  assertGeneratorOutput 
} from '@atomic-ehr/codegen/testing';

// Test a generator
await runGeneratorTest(async (fixture) => {
  // Register a test generator
  fixture.registerTestGenerator({
    id: 'test-gen',
    name: 'Test Generator',
  });
  
  // Create and test the generator
  const generator = await fixture.createGenerator('test-gen');
  await assertGeneratorOutput(generator, [
    { path: 'output.txt', content: 'expected content' }
  ]);
});
```

### Mock Generator

Use the built-in mock generator for testing:

```typescript
import { MockGenerator, createMockGeneratorFactory } from '@atomic-ehr/codegen/testing';

const factory = createMockGeneratorFactory(MockGenerator);
const generator = factory({ outputDir: '/tmp/test' });

await generator.generate();
console.log(generator.generatedFiles); // Array of generated files
```

## Error Handling

The registry system provides specific error types:

- `GeneratorNotFoundError` - Generator ID not found in registry
- `GeneratorAlreadyRegisteredError` - Attempting to register duplicate ID
- `InvalidGeneratorError` - Generator doesn't meet interface requirements
- `PluginLoadError` - Failed to load external plugin
- `GeneratorRegistryError` - General registry operation error

```typescript
import { 
  GeneratorNotFoundError,
  defaultRegistry 
} from '@atomic-ehr/codegen';

try {
  const generator = await defaultRegistry.create('nonexistent', options);
} catch (error) {
  if (error instanceof GeneratorNotFoundError) {
    console.log('Available generators:', defaultRegistry.list().map(g => g.id));
  }
}
```

## Best Practices

### Generator Development

1. **Extend BaseGenerator**: Use the provided base class for common functionality
2. **Implement Validation**: Add custom validation logic in the `validate()` method
3. **Handle Cleanup**: Implement `cleanup()` for resource management
4. **Use Metadata**: Provide comprehensive metadata for discovery
5. **Test Thoroughly**: Use the testing utilities to ensure reliability

### Plugin Development

1. **Follow Naming Conventions**: Include "generator" or "plugin" in filenames
2. **Export Multiple Formats**: Support both named exports and plugin objects
3. **Validate Configuration**: Implement plugin-level validation
4. **Document Options**: Provide clear configuration schema
5. **Handle Errors Gracefully**: Don't crash the entire system

### Registry Usage

1. **Initialize Early**: Call `ensureInitialized()` before using generators
2. **Handle Missing Generators**: Check if generators exist before using
3. **Use Appropriate Options**: Configure generators properly for your use case
4. **Monitor Plugin Loading**: Check for plugin loading errors in logs
5. **Test Integration**: Verify that custom plugins work with the CLI

## Migration Guide

### From Direct Generator Usage

Before (direct usage):
```typescript
import { TypeScriptGenerator } from './generators/typescript';

const generator = new TypeScriptGenerator({ outputDir: './out' });
await generator.generate();
```

After (registry usage):
```typescript
import { defaultRegistry, ensureInitialized } from '@atomic-ehr/codegen';

await ensureInitialized();
const generator = await defaultRegistry.create('typescript', { outputDir: './out' });
await generator.generate();
```

### CLI Command Changes

The CLI maintains backward compatibility, but now uses the registry:

```bash
# Old command still works
atomic-codegen generate typescript -i input.json -o ./out

# New generator management commands
atomic-codegen generators list
atomic-codegen generators info typescript
```

## Troubleshooting

### Common Issues

1. **Generator Not Found**
   - Check that the generator is registered: `generators list`
   - Verify plugin loading: use `--verbose` flag
   - Check plugin file naming and exports

2. **Plugin Loading Fails**
   - Verify file permissions and accessibility
   - Check plugin export format
   - Review plugin metadata completeness

3. **Validation Errors**
   - Ensure all required metadata fields are present
   - Verify generator implements required methods
   - Check configuration schema validity

### Debug Mode

Enable debug logging to troubleshoot issues:

```bash
atomic-codegen --debug generators list
atomic-codegen --debug generate typescript -i input.json -o ./out
```

Or programmatically:

```typescript
import { initializeGeneratorSystem } from '@atomic-ehr/codegen';

await initializeGeneratorSystem({
  ignorePluginErrors: false, // Fail on plugin errors
});
```
