# Creating Custom Writers for Code Generation

This guide explains how to build your own code generator for a new programming language or framework by extending the `Writer` class in Atomic EHR Codegen.

---

## Table of Contents

- [Architecture Overview](#architecture-overview)
- [Writer Class Fundamentals](#writer-class-fundamentals)
- [Understanding TypeSchemaIndex](#understanding-typeschemaindex)
- [Implementation Pattern](#implementation-pattern)
- [File & Directory Management](#file--directory-management)
- [Code Generation Methods](#code-generation-methods)

---

## Architecture Overview

The code generation pipeline consists of three stages:

```
FHIR Packages
    ↓
TypeSchema (Universal Format)
    ↓
Writer (Language-Specific)
    ↓
Generated Code
```

The `Writer` class handles the output stage, transforming TypeSchema data into language-specific code. There are two main base classes:

### FileSystemWriter

Base class handling file I/O and directory management.

- Creates and manages output files and directories
- Supports both in-memory and on-disk writing
- Provides buffer management for generated content

### Writer
Extends `FileSystemWriter` with code generation utilities.
- Handles indentation and formatting
- Provides methods for common code patterns (blocks, comments, lines)
- Supports language-specific code constructs

---

## Writer Class Fundamentals

### Constructor & Options

Every writer needs options to configure behavior:

```typescript
export type WriterOptions = {
    outputDir: string;                    // Where to write files
    tabSize: number;                      // Indentation size (spaces)
    commentLinePrefix: string;            // Comment syntax (e.g., "//", "#")
    withDebugComment?: boolean;           // Include debug info in output
    generateProfile?: boolean;            // Generate profile-related types
    inMemoryOnly?: boolean;               // Don't write to disk (for testing)
    logger?: CodegenLogger;               // Optional logging
};
```

### Core Methods

#### File Management
```typescript
cd(path: string, gen: () => void)
  Creates a subdirectory and executes generation code within it
  Example: this.cd("models", () => { /* generate model files */ })

cat(filename: string, gen: () => void)
  Opens a file for writing and executes generation code
  Example: this.cat("patient.ts", () => { /* write file content */ })

write(str: string)
  Writes a string to the currently open file
  Example: this.write("class Patient {")
```

#### Code Writing Methods
```typescript
line(...tokens: string[])
  Writes an indented line with automatic newline
  Example: this.line("public class Patient {")

lineSM(...tokens: string[])
  Writes a line ending with semicolon (statement)
  Example: this.lineSM("int age = 25")

comment(...tokens: string[])
  Writes a comment line with language-appropriate prefix
  Example: this.comment("This is a patient resource")

indentBlock(gencontent: () => void)
  Increases indentation, executes content, then decreases
  Example: this.indentBlock(() => { this.line("return patient;") })

curlyBlock(tokens, gencontent, endTokens?)
  Writes { ... } block with proper indentation
  Example: this.curlyBlock(["class Patient"], () => { /* body */ })

squareBlock(tokens, gencontent, endTokens?)
  Writes [ ... ] block with proper indentation
  Example: this.squareBlock(["List<Patient>"], () => { /* items */ })
```

#### Metadata
```typescript
disclaimer()
  Returns warning text about autogenerated code

generateDisclaimer()
  Writes the disclaimer comment to current file

writtenFiles(): FileBuffer[]
  Returns all generated files with content
```

---

## Understanding TypeSchemaIndex

Before implementing a writer, you need to understand the input your `generate()` method receives: a `TypeSchemaIndex`.

### What is TypeSchemaIndex?

The `TypeSchemaIndex` is a structured collection containing all transformed FHIR definitions in TypeSchema format. It serves as the complete data model for code generation.

```typescript
interface TypeSchemaIndex {
    index: Record<string, TypeSchema>;  // Map of all schemas by identifier
}
```

### Structure

```typescript
// Example TypeSchemaIndex content
const tsIndex: TypeSchemaIndex = {
    index: {
        "hl7.fhir.r4.core#4.0.1|Patient": {
            id: { /* identifier */ },
            name: "Patient",
            description: "Demographics and other administrative information...",
            fields: [
                { name: "id", type: "string", required: true, array: false },
                { name: "identifier", type: "Identifier", required: false, array: true },
                { name: "active", type: "boolean", required: false, array: false },
                { name: "name", type: "HumanName", required: false, array: true },
            ],
            dependencies: [
                { kind: "complex", name: "Identifier", package: "hl7.fhir.r4.core" },
                { kind: "complex", name: "HumanName", package: "hl7.fhir.r4.core" },
            ],
            base: "Resource",
        },
        "hl7.fhir.r4.core#4.0.1|Observation": {
            // Another type definition...
        },
        // ... hundreds more types
    }
};
```

### Key Properties

- **index**: A key-value map where:
  - **Key**: Fully qualified identifier (format: `package#version|name`)
  - **Value**: `TypeSchema` object containing the type definition

- **TypeSchema object contains**:
  - `id`: Unique identifier with package and version info
  - `name`: Type name (e.g., "Patient", "Observation")
  - `description`: Human-readable documentation
  - `fields`: Array of field/property definitions
  - `dependencies`: References to other types this type depends on
  - `base`: Parent type name (for inheritance)

### Accessing Data

```typescript
// Get a specific schema by identifier
const patientSchema = tsIndex.index["hl7.fhir.r4.core#4.0.1|Patient"];

// Get all values (all schemas)
const allSchemas = Object.values(tsIndex.index);

// Get all keys (all identifiers)
const allIds = Object.keys(tsIndex.index);

// Iterate through all types
for (const [id, schema] of Object.entries(tsIndex.index)) {
    console.log(`Processing ${schema.name} from ${id}`);
}
```

### Helper Functions

Atomic EHR Codegen provides utilities for common TypeSchemaIndex operations:

```typescript
import { groupByPackages, sortAsDeclarationSequence } from "@root/typeschema/utils";

// Group all schemas by package
const byPackage = groupByPackages(tsIndex.index);
// Returns: Record<string, TypeSchema[]> - organized by package

// Sort schemas in dependency order (ensures base types come first)
const sorted = sortAsDeclarationSequence(tsIndex.index);
// Returns: TypeSchema[] - topologically sorted by dependencies
```

### Typical Processing Pattern

```typescript
async generate(tsIndex: TypeSchemaIndex): Promise<void> {
    // Option 1: Process all types
    for (const schema of Object.values(tsIndex.index)) {
        this.generateType(schema);
    }

    // Option 2: Group by package first (recommended)
    const packages = groupByPackages(tsIndex.index);
    for (const [pkgName, schemas] of Object.entries(packages)) {
        this.cd(packageToDir(pkgName), () => {
            for (const schema of schemas) {
                this.generateType(schema);
            }
        });
    }

    // Option 3: Sort by dependencies (for languages needing declaration order)
    const sorted = sortAsDeclarationSequence(tsIndex.index);
    for (const schema of sorted) {
        this.generateType(schema);
    }
}
```

### Why TypeSchemaIndex Matters

- **Complete Data**: Contains ALL types from the FHIR package
- **Already Transformed**: Types converted from FHIR StructureDefinition to TypeSchema
- **Dependencies Resolved**: References between types already established
- **Organized**: Can group by package, sort by dependencies, or iterate directly
- **Read-Only**: Frozen snapshot; writes go through Writer methods only

---

## Implementation Pattern

### Step 1: Extend the Writer Class

```typescript
import { Writer, type WriterOptions } from "@root/api/writer-generator/writer";
import type { TypeSchemaIndex } from "@root/typeschema/utils";

export interface MyLanguageOptions extends WriterOptions {
    // Add language-specific options
    packageName?: string;
    includeValidation?: boolean;
}

export class MyLanguageWriter extends Writer<MyLanguageOptions> {
    constructor(opts: MyLanguageOptions) {
        super({
            ...opts,
            tabSize: 4,                    // 4 spaces for indentation
            commentLinePrefix: "//",       // C-style comments
        });
    }

    async generate(tsIndex: TypeSchemaIndex): Promise<void> {
        // Main generation logic goes here
    }
}
```

### Step 2: Implement the `generate` Method

The `generate` method receives a `TypeSchemaIndex` as input (see section above for details). This contains all the TypeSchema definitions you need to process:

```typescript
async generate(tsIndex: TypeSchemaIndex): Promise<void> {
    // 1. Write disclaimer
    this.cat("_generated.txt", () => {
        this.generateDisclaimer();
    });

    // 2. Group schemas by package (optional)
    const packages = groupByPackages(tsIndex.index);

    // 3. Generate files for each package
    for (const [pkgName, schemas] of Object.entries(packages)) {
        this.cd(packageToDir(pkgName), () => {
            for (const schema of schemas) {
                this.generateType(schema);
            }
        });
    }
}
```

### Step 3: Implement Type Generation

```typescript
private generateType(schema: TypeSchema): void {
    const fileName = `${schema.name}.java`;

    this.cat(fileName, () => {
        this.generateDisclaimer();
        this.line();

        // Package declaration
        if (this.opts.packageName) {
            this.line(`package ${this.opts.packageName};`);
            this.line();
        }

        // Imports
        this.generateImports(schema);
        this.line();

        // Class definition
        const baseClass = schema.base ? ` extends ${schema.base}` : "";
        this.curlyBlock([`public class ${schema.name}${baseClass}`], () => {
            this.generateFields(schema);
            this.generateMethods(schema);
        });
    });
}
```

---

## File & Directory Management

### Directory Structure

Use `cd()` to organize generated code into directories:

```typescript
this.cd("src/main/java", () => {
    this.cd("com/example/fhir", () => {
        this.cat("Patient.java", () => {
            this.line("public class Patient {");
            // ...
            this.line("}");
        });
    });
});
```

Results in structure:
```
output/
  src/
    main/
      java/
        com/
          example/
            fhir/
              Patient.java
```

### Multiple Files Per Type

For complex types, generate multiple related files:

```typescript
private generateType(schema: TypeSchema): void {
    // Main interface
    this.cat(`I${schema.name}.java`, () => {
        this.generateInterface(schema);
    });

    // Implementation
    this.cat(`${schema.name}.java`, () => {
        this.generateClass(schema);
    });

    // Builder pattern
    this.cat(`${schema.name}Builder.java`, () => {
        this.generateBuilder(schema);
    });
}
```

### In-Memory Only Mode

For testing without disk I/O:

```typescript
const testWriter = new MyLanguageWriter({
    outputDir: "/tmp/test",
    inMemoryOnly: true,  // No files written to disk
    tabSize: 4,
    commentLinePrefix: "//",
});

const files = testWriter.writtenFiles();
console.log(files[0].content);
```

---

## Code Generation Methods

### Indentation Handling

The `Writer` class automatically tracks indentation:

```typescript
this.line("public class Patient {");          // No indent
this.indentBlock(() => {
    this.line("private String name;");        // 4 spaces
    this.indentBlock(() => {
        this.line("return name;");            // 8 spaces
    });
});
this.line("}");                               // No indent
```

Output:
```java
public class Patient {
    private String name;
        return name;
}
```

### Block Generation

#### Curly Blocks (Classes, Methods, Control Flow)

```typescript
this.curlyBlock(["public void process()"], () => {
    this.line("System.out.println(\"Processing\");");
});
```

Output:
```java
public void process() {
    System.out.println("Processing");
}
```

#### Square Blocks (Arrays, Collections)

```typescript
this.squareBlock(["List<String> names = new ArrayList"], () => {
    this.line('"John",');
    this.line('"Jane",');
    this.line('"Bob"');
});
```

Output:
```java
List<String> names = new ArrayList [
    "John",
    "Jane",
    "Bob"
]
```

### Comments & Documentation

```typescript
// Single line comment
this.comment("This is a comment");

// Multi-line comment (automatic line breaking)
this.comment("This is a longer comment that might span multiple lines and will be split automatically");

// Debug comments (only if withDebugComment: true)
this.debugComment("Type info:", schema);

// Disclaimer
this.generateDisclaimer();
```

---

## Next Steps

1. **Read the Source**: Review TypeScript and Python writers for more patterns
   - `src/api/writer-generator/typescript.ts`
   - `src/api/writer-generator/python.ts`

2. **Test Your Writer**: Write unit and integration tests
   - Use in-memory mode for unit tests
   - Test with real FHIR packages for integration tests

3. **Integrate with APIBuilder**: Add your writer as a chainable method

4. **Share**: Consider contributing your writer back to the project!

---

## Resources

- **Writer Class**: `src/api/writer-generator/writer.ts`
- **TypeSchema Definition**: `src/typeschema/types.ts`
- **Existing Writers**: `src/api/writer-generator/`
- **APIBuilder**: `src/api/builder.ts`
- **Tests**: `test/unit/api/`
