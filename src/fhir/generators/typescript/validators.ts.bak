/**
 * TypeScript Validator Generator for FHIR Resources
 *
 * Generates runtime validation functions for FHIR resources and types.
 * Provides comprehensive validation including cardinality, constraints, and invariants.
 */

import type { AnyTypeSchema, TypeSchemaField } from "../../../typeschema/lib-types";
import { 
  BaseValidator, 
  ValidationResult, 
  ValidationError, 
  ValidationContext, 
  ValidatorOptions, 
  ValidationErrorCodes, 
  ValidationUtils, 
  CardinalityConstraint, 
  ReferenceConstraint,
  ValidationMetrics,
  ValidationRule
} from "../../core/validation";

/**
 * Validation function type
 */
export type ValidatorFunction<T = any> = (value: unknown, options?: Partial<ValidatorOptions>) => ValidationResult<T>;

/**
 * Schema-based validator class
 */
export class SchemaValidator {
  private validatorCache = new Map<string, ValidatorFunction>();
  private options: ValidatorOptions;

  constructor(options: Partial<ValidatorOptions> = {}) {
    this.options = {
      includeCardinality: true,
      includeTypes: true,
      includeConstraints: true,
      includeInvariants: false,
      validateRequired: true,
      allowAdditional: false,
      strict: false,
      collectMetrics: false,
      maxDepth: 10,
      customRules: [],
      ...options,
    };
  }

  /**
   * Validate a resource using cached validator
   */
  validate<T extends { resourceType: string }>(
    resourceType: T['resourceType'],
    value: unknown,
    options?: Partial<ValidatorOptions>
  ): ValidationResult<T> {
    const mergedOptions = { ...this.options, ...options };
    const validator = this.getValidator(resourceType);
    
    if (!validator) {
      return {
        valid: false,
        errors: [{
          message: `No validator available for resource type: ${resourceType}`,
          path: [],
          code: ValidationErrorCodes.INVALID_RESOURCE_TYPE,
          severity: 'error',
          expected: 'known resource type',
          actual: resourceType,
        }],
        warnings: [],
      };
    }

    return validator(value, mergedOptions) as ValidationResult<T>;
  }

  /**
   * Validate partial resource (for updates)
   */
  validatePartial<T extends { resourceType: string }>(
    resourceType: T['resourceType'],
    value: Partial<T>,
    options?: Partial<ValidatorOptions>
  ): ValidationResult<Partial<T>> {
    const mergedOptions = { 
      ...this.options, 
      ...options, 
      validateRequired: false // Don't require all fields for partial validation
    };
    
    return this.validate(resourceType, value, mergedOptions) as ValidationResult<Partial<T>>;
  }

  /**
   * Get or create validator for resource type
   */
  private getValidator(resourceType: string): ValidatorFunction | null {
    if (this.validatorCache.has(resourceType)) {
      return this.validatorCache.get(resourceType)!;
    }

    // This would be populated with generated validators
    const generatedValidator = this.createDynamicValidator(resourceType);
    if (generatedValidator) {
      this.validatorCache.set(resourceType, generatedValidator);
      return generatedValidator;
    }

    return null;
  }

  /**
   * Create dynamic validator (placeholder for generated code)
   */
  private createDynamicValidator(resourceType: string): ValidatorFunction | null {
    // This would be replaced with actual generated validator logic
    return null;
  }

  /**
   * Register a custom validator
   */
  registerValidator(resourceType: string, validator: ValidatorFunction): void {
    this.validatorCache.set(resourceType, validator);
  }

  /**
   * Clear validator cache
   */
  clearCache(): void {
    this.validatorCache.clear();
  }
}

/**
 * Validator generation options (extends base ValidatorOptions)
 */
export interface ValidatorGenerationOptions extends ValidatorOptions {
	/** Generate assertion functions alongside validators */
	generateAssertions?: boolean;
	/** Generate partial validators for updates */
	generatePartialValidators?: boolean;
	/** Include performance optimizations */
	optimizePerformance?: boolean;
	/** Include detailed JSDoc documentation */
	includeJSDoc?: boolean;
	/** Generate composite validators */
	generateCompositeValidators?: boolean;
}

/**
 * Generate comprehensive validators from schemas
 */
export function generateValidators(
	schemas: AnyTypeSchema[],
	options: ValidatorGenerationOptions = {},
): string {
	const validators: string[] = [];
	const helperFunctions: string[] = [];
	const compositeValidators: string[] = [];
	
	// Set default options
	const fullOptions: ValidatorGenerationOptions = {
		includeCardinality: true,
		includeTypes: true,
		includeConstraints: true,
		includeInvariants: false,
		validateRequired: true,
		allowAdditional: false,
		strict: false,
		collectMetrics: false,
		maxDepth: 10,
		generateAssertions: true,
		generatePartialValidators: true,
		optimizePerformance: true,
		includeJSDoc: true,
		generateCompositeValidators: true,
		...options,
	};
	
	// Generate helper functions first
	helperFunctions.push(generateHelperFunctions());
	helperFunctions.push(generateValidationUtilities(fullOptions));
	
	// Generate validators for each schema
	for (const schema of schemas) {
		const validator = generateValidator(schema, fullOptions);
		if (validator) {
			validators.push(validator);
		}
		
		// Generate partial validator if requested
		if (fullOptions.generatePartialValidators) {
			const partialValidator = generatePartialValidator(schema, fullOptions);
			if (partialValidator) {
				validators.push(partialValidator);
			}
		}
		
		// Generate assertion function if requested
		if (fullOptions.generateAssertions) {
			const assertionFunction = generateAssertionFunction(schema, fullOptions);
			if (assertionFunction) {
				validators.push(assertionFunction);
			}
		}
	}
	
	// Generate composite validators
	if (fullOptions.generateCompositeValidators) {
		compositeValidators.push(generateCompositeValidatorClass(schemas, fullOptions));
		compositeValidators.push(generateValidatorFactory(schemas, fullOptions));
	}
	
	// Add header
	const header = generateValidatorHeader();
	
	return [
		header, 
		...helperFunctions, 
		...validators, 
		...compositeValidators
	].filter(Boolean).join('\n\n');
}

/**
 * Generate comprehensive validator for a single schema
 */
function generateValidator(
	schema: AnyTypeSchema,
	options: ValidatorGenerationOptions,
): string {
	if (!("identifier" in schema)) return "";
	
	const validatorName = `validate${schema.identifier.name}`;
	const typeName = schema.identifier.name;
	
	if ("fields" in schema && schema.fields) {
		const validation = generateFieldValidation(schema.fields, options);
		const jsDoc = options.includeJSDoc ? generateValidatorJSDoc(schema, options) : '';
		
		return `${jsDoc}
export function ${validatorName}(
  value: unknown,
  options: Partial<ValidatorOptions> = {}
): ValidationResult<${typeName}> {
  ${options.collectMetrics ? 'const startTime = performance.now();' : 'const startTime = 0;'}
  const errors: ValidationError[] = [];
  const warnings: ValidationError[] = [];
  let fieldsValidated = 0;
  
  // Merge options with defaults
  const opts: ValidatorOptions = {
    includeCardinality: ${options.includeCardinality},
    includeTypes: ${options.includeTypes},
    includeConstraints: ${options.includeConstraints},
    validateRequired: ${options.validateRequired},
    allowAdditional: ${options.allowAdditional},
    strict: ${options.strict},
    maxDepth: ${options.maxDepth || 10},
    ...options,
  };
  
  // Basic type check
  if (!value || typeof value !== 'object') {
    errors.push({
      message: 'Expected object',
      path: [],
      code: ValidationErrorCodes.INVALID_TYPE,
      severity: 'error',
      expected: 'object',
      actual: ValidationUtils.getTypeName(value),
    });
    return createValidationResult(false, undefined, errors, warnings, startTime, fieldsValidated, opts);
  }
  
  const obj = value as Record<string, unknown>;
  
  // Resource type validation for resources
  ${schema.identifier.kind === 'resource' ? `
  if (obj.resourceType !== '${typeName}') {
    errors.push({
      message: \`Expected resourceType '${typeName}', got '\${obj.resourceType}'\`,
      path: ['resourceType'],
      code: ValidationErrorCodes.INVALID_RESOURCE_TYPE,
      severity: 'error',
      expected: '${typeName}',
      actual: obj.resourceType,
    });
  }
  fieldsValidated++;` : ''}
  
  ${validation}
  
  // Check for additional properties if not allowed
  if (!opts.allowAdditional) {
    const allowedFields = new Set([${Object.keys(schema.fields || {}).map(f => `'${f}'`).join(', ')}]);
    ${schema.identifier.kind === 'resource' ? "allowedFields.add('resourceType');" : ''}
    
    for (const key of Object.keys(obj)) {
      if (!allowedFields.has(key)) {
        warnings.push({
          message: \`Unexpected property '\${key}'\`,
          path: [key],
          code: ValidationErrorCodes.UNEXPECTED_FIELD,
          severity: 'warning',
          actual: key,
        });
      }
    }
  }
  
  const valid = errors.length === 0 && (opts.strict ? warnings.length === 0 : true);
  return createValidationResult(
    valid,
    valid ? obj as ${typeName} : undefined,
    errors,
    warnings,
    startTime,
    fieldsValidated,
    opts
  );
}`;
	}
	
	// Handle primitive types
	if (schema.identifier.kind === "primitive-type") {
		return generatePrimitiveValidator(schema, options);
	}
	
	return "";
}

/**
 * Generate comprehensive field validation code
 */
function generateFieldValidation(
	fields: Record<string, TypeSchemaField>,
	options: ValidatorGenerationOptions,
): string {
	const validations: string[] = [];
	
	for (const [fieldName, field] of Object.entries(fields)) {
		const fieldValidation = generateSingleFieldValidation(fieldName, field, options);
		if (fieldValidation) {
			validations.push(fieldValidation);
		}
	}
	
	return validations.length > 0 ? validations.join('\n\n  ') : '  // No field validation required';
}

/**
 * Generate comprehensive validation for a single field
 */
function generateSingleFieldValidation(
	fieldName: string,
	field: TypeSchemaField,
	options: ValidatorGenerationOptions,
): string {
	const validations: string[] = [];
	const fieldPath = `[${JSON.stringify(fieldName)}]`;
	
	// Field existence and requirement check
	if (options.validateRequired && field.required) {
		validations.push(`// Validate required field: ${fieldName}
  if (!(${JSON.stringify(fieldName)} in obj) || obj[${JSON.stringify(fieldName)}] == null) {
    errors.push({
      message: 'Required field "${fieldName}" is missing',
      path: ${fieldPath},
      code: ValidationErrorCodes.MISSING_REQUIRED_FIELD,
      severity: 'error',
      expected: 'defined value',
      actual: obj[${JSON.stringify(fieldName)}],
    });
  } else {
    fieldsValidated++;`);
	} else {
		validations.push(`// Validate optional field: ${fieldName}
  if (${JSON.stringify(fieldName)} in obj && obj[${JSON.stringify(fieldName)}] != null) {
    fieldsValidated++;`);
	}
	
	// Type validation
	if (options.includeTypes) {
		const typeValidation = generateTypeValidation(fieldName, field);
		if (typeValidation) {
			validations.push(`    ${typeValidation}`);
		}
	}
	
	// Cardinality validation for arrays
	if (options.includeCardinality && field.array) {
		validations.push(`    // Cardinality validation for ${fieldName}
    if (!Array.isArray(obj[${JSON.stringify(fieldName)}])) {
      errors.push({
        message: 'Field "${fieldName}" must be an array',
        path: ${fieldPath},
        code: ValidationErrorCodes.ARRAY_REQUIRED,
        severity: 'error',
        expected: 'array',
        actual: ValidationUtils.getTypeName(obj[${JSON.stringify(fieldName)}]),
      });
    } else {
      const arr = obj[${JSON.stringify(fieldName)}] as unknown[];
      ${generateArrayCardinalityValidation(fieldName, field)}
      
      // Validate each array element
      arr.forEach((item, index) => {
        const itemPath = [...${fieldPath}, index];
        ${generateArrayItemValidation(fieldName, field)}
      });
    }`);
	} else if (field.minItems !== undefined || field.maxItems !== undefined) {
		// Single value treated as array length 1 for min/max validation
		validations.push(`    // Single value cardinality check for ${fieldName}
    ${field.minItems && field.minItems > 1 ? `
    errors.push({
      message: 'Field "${fieldName}" requires at least ${field.minItems} items but is not an array',
      path: ${fieldPath},
      code: ValidationErrorCodes.MIN_CARDINALITY,
      severity: 'error',
      expected: 'array with >= ${field.minItems} items',
      actual: 'single value',
    });` : ''}
    ${field.maxItems && field.maxItems < 1 ? `
    errors.push({
      message: 'Field "${fieldName}" allows maximum ${field.maxItems} items',
      path: ${fieldPath},
      code: ValidationErrorCodes.MAX_CARDINALITY,
      severity: 'error',
      expected: 'no value',
      actual: 'single value',
    });` : ''}`);
	}
	
	// Reference validation
	if (options.includeConstraints && field.type === 'Reference') {
		validations.push(`    // Reference validation for ${fieldName}
    if (!validateReference(obj[${JSON.stringify(fieldName)}], ${fieldPath})) {
      // Reference validation errors are added by validateReference function
    }`);
	}
	
	// Choice type validation
	if ('choices' in field && field.choices) {
		validations.push(`    // Choice type validation for ${fieldName}
    const choiceResult = validateChoiceField(obj, '${fieldName.replace('[x]', '')}', [${field.choices.map(c => `'${c}'`).join(', ')}]);
    if (!choiceResult.valid) {
      errors.push(...choiceResult.errors.map(err => ({
        ...err,
        path: [...${fieldPath}, ...err.path],
      })));
    }`);
	}
	
	// Pattern constraint validation
	if (field.pattern) {
		validations.push(`    // Pattern validation for ${fieldName}
    if (typeof obj[${JSON.stringify(fieldName)}] === 'string' && !ValidationUtils.matchesPattern(obj[${JSON.stringify(fieldName)}], ${JSON.stringify(field.pattern)})) {
      errors.push({
        message: 'Field "${fieldName}" does not match required pattern',
        path: ${fieldPath},
        code: ValidationErrorCodes.PATTERN_MISMATCH,
        severity: 'error',
        expected: 'pattern: ${field.pattern}',
        actual: obj[${JSON.stringify(fieldName)}],
      });
    }`);
	}
	
	// Custom constraint validation
	if (options.includeConstraints && field.constraints) {
		const constraintValidation = generateConstraintValidation(fieldName, field.constraints);
		if (constraintValidation) {
			validations.push(`    ${constraintValidation}`);
		}
	}
	
	validations.push('  }');
	
	return validations.join('\n');
}

/**
 * Generate type validation for a field
 */
function generateTypeValidation(fieldName: string, field: TypeSchemaField): string {
	const fieldValue = `obj[${JSON.stringify(fieldName)}]`;
	
	// Handle choice types
	if ("choices" in field && field.choices) {
		const choiceValidations = field.choices.map(choice => 
			`validate${choice.charAt(0).toUpperCase() + choice.slice(1)}(${fieldValue}).valid`
		);
		
		return `// Choice type validation for ${fieldName}
		if (!(${choiceValidations.join(' || ')})) {
			errors.push({
				message: 'Field "${fieldName}" must be one of: ${field.choices.join(', ')}',
				path: [${JSON.stringify(fieldName)}],
				code: 'INVALID_CHOICE_TYPE',
				severity: 'error',
				expected: [${field.choices.map(c => `'${c}'`).join(', ')}],
				actual: typeof ${fieldValue},
			});
		}`;
	}
	
	// Handle regular types
	const expectedType = getExpectedJSType(field.type || "string");
	if (expectedType) {
		return `// Type validation for ${fieldName}
		if (typeof ${fieldValue} !== '${expectedType}') {
			errors.push({
				message: 'Field "${fieldName}" must be of type ${expectedType}',
				path: [${JSON.stringify(fieldName)}],
				code: 'INVALID_TYPE',
				severity: 'error',
				expected: '${expectedType}',
				actual: typeof ${fieldValue},
			});
		}`;
	}
	
	return "";
}

/**
 * Generate array cardinality validation
 */
function generateArrayCardinalityValidation(fieldName: string, field: TypeSchemaField): string {
	const validations: string[] = [];
	
	if (field.minItems !== undefined) {
		validations.push(`if (arr.length < ${field.minItems}) {
				errors.push({
					message: 'Field "${fieldName}" must have at least ${field.minItems} items',
					path: [${JSON.stringify(fieldName)}],
					code: 'MIN_CARDINALITY',
					severity: 'error',
					expected: '>= ${field.minItems}',
					actual: arr.length,
				});
			}`);
	}
	
	if (field.maxItems !== undefined) {
		validations.push(`if (arr.length > ${field.maxItems}) {
				errors.push({
					message: 'Field "${fieldName}" must have at most ${field.maxItems} items',
					path: [${JSON.stringify(fieldName)}],
					code: 'MAX_CARDINALITY',
					severity: 'error',
					expected: '<= ${field.maxItems}',
					actual: arr.length,
				});
			}`);
	}
	
	return validations.join('\n\t\t\t');
}

/**
 * Generate constraint validation
 */
function generateConstraintValidation(fieldName: string, constraints: any): string {
	// This would be expanded based on specific constraint types
	return `// Constraint validation for ${fieldName} (implementation needed)`;
}

/**
 * Generate primitive type validator
 */
function generatePrimitiveValidator(
	schema: AnyTypeSchema,
	options: ValidatorGenerationOptions,
): string {
	const validatorName = `validate${schema.identifier.name}`;
	const typeName = schema.identifier.name;
	const jsType = getExpectedJSType(typeName);
	
	let typeCheck = `typeof value === '${jsType}'`;
	
	// Add specific validation for FHIR primitives
	switch (typeName) {
		case "id":
			typeCheck = `typeof value === 'string' && /^[A-Za-z0-9\\-\\.]{1,64}$/.test(value)`;
			break;
		case "date":
			typeCheck = `typeof value === 'string' && /^\\d{4}-\\d{2}-\\d{2}$/.test(value) && !isNaN(Date.parse(value + 'T00:00:00Z'))`;
			break;
		case "dateTime":
			typeCheck = `typeof value === 'string' && /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{1,3})?(Z|[+-]\\d{2}:\\d{2})$/.test(value) && !isNaN(Date.parse(value))`;
			break;
		case "uri":
		case "url":
			typeCheck = `typeof value === 'string' && isValidURI(value)`;
			break;
	}
	
	return `/**
 * Validate ${typeName} primitive
 */
export function ${validatorName}(value: unknown): ValidationResult<${typeName}> {
	const errors: ValidationError[] = [];
	const warnings: ValidationError[] = [];
	
	if (!(${typeCheck})) {
		errors.push({
			message: 'Invalid ${typeName} value',
			path: [],
			code: 'INVALID_PRIMITIVE',
			severity: 'error',
			expected: '${typeName}',
			actual: typeof value,
		});
		return { valid: false, errors, warnings };
	}
	
	return {
		valid: true,
		value: value as ${typeName},
		errors,
		warnings,
	};
}`;
}

/**
 * Get expected JavaScript type for FHIR type
 */
function getExpectedJSType(fhirType: string): string {
	const typeMapping: Record<string, string> = {
		string: "string",
		boolean: "boolean",
		integer: "number",
		decimal: "number",
		date: "string",
		dateTime: "string",
		time: "string",
		instant: "string",
		uri: "string",
		url: "string",
		canonical: "string",
		id: "string",
		oid: "string",
		uuid: "string",
		markdown: "string",
		code: "string",
		base64Binary: "string",
		unsignedInt: "number",
		positiveInt: "number",
		xhtml: "string",
	};
	
	return typeMapping[fhirType] || "object";
}

/**
 * Generate helper functions
 */
function generateHelperFunctions(): string {
	return `/**
 * Helper function to validate URI format
 */
function isValidURI(value: string): boolean {
	try {
		new URL(value);
		return true;
	} catch {
		// Allow relative URIs and URNs
		return /^[a-zA-Z][a-zA-Z0-9+.-]*:|^\\/|^[a-zA-Z0-9._~:/?#[\\]@!$&'()*+,;=%-]+$/.test(value);
	}
}

/**
 * Helper function to validate date format
 */
function isValidDate(value: string): boolean {
	return !isNaN(Date.parse(value));
}

/**
 * Helper function to merge validation results
 */
export function mergeValidationResults(...results: ValidationResult[]): ValidationResult {
	const allErrors = results.flatMap(r => r.errors);
	const allWarnings = results.flatMap(r => r.warnings);
	const valid = results.every(r => r.valid);
	
	return {
		valid,
		errors: allErrors,
		warnings: allWarnings,
	};
}`;
}

/**
 * Generate array item validation
 */
function generateArrayItemValidation(fieldName: string, field: TypeSchemaField): string {
	if (field.type) {
		const jsType = getExpectedJSType(field.type);
		if (jsType && jsType !== 'object') {
			return `if (typeof item !== '${jsType}') {
          errors.push({
            message: 'Array item in "${fieldName}" must be of type ${jsType}',
            path: itemPath,
            code: ValidationErrorCodes.INVALID_TYPE,
            severity: 'error',
            expected: '${jsType}',
            actual: ValidationUtils.getTypeName(item),
          });
        }`;
		}
	}
	return '// Array item validation - implement based on item type';
}

/**
 * Generate missing helper functions for comprehensive validation
 */
function generateValidationUtilities(options: ValidatorGenerationOptions): string {
	return `/**
 * Create validation result with metrics
 */
function createValidationResult<T>(
  valid: boolean,
  value: T | undefined,
  errors: ValidationError[],
  warnings: ValidationError[],
  startTime: number,
  fieldsValidated: number,
  options: ValidatorOptions
): ValidationResult<T> {
  const result: ValidationResult<T> = {
    valid,
    value,
    errors,
    warnings,
  };

  if (options.collectMetrics && startTime > 0) {
    result.metrics = {
      duration: performance.now() - startTime,
      fieldsValidated,
      complexity: errors.length + warnings.length + fieldsValidated,
    };
  }

  return result;
}

/**
 * Validate reference field
 */
function validateReference(
  value: unknown,
  path: string[]
): boolean {
  if (!value || typeof value !== 'object') {
    return false;
  }

  const ref = value as Record<string, unknown>;
  
  // Must have either reference or identifier
  if (!('reference' in ref) && !('identifier' in ref) && !('display' in ref)) {
    return false;
  }

  // Validate reference format if present
  if ('reference' in ref && typeof ref.reference === 'string') {
    const refPattern = /^([A-Z][a-zA-Z]+)\\/([A-Za-z0-9\\-\\.]{1,64})(\\/_history\\/[A-Za-z0-9\\-\\.]{1,64})?$/;
    return refPattern.test(ref.reference);
  }

  return true;
}

/**
 * Validate choice field (value[x] pattern)
 */
function validateChoiceField(
  obj: Record<string, unknown>,
  baseName: string,
  allowedTypes: string[]
): ValidationResult<boolean> {
  const errors: ValidationError[] = [];
  const warnings: ValidationError[] = [];
  const presentChoices: string[] = [];

  // Find all present choice properties
  for (const type of allowedTypes) {
    const propertyName = baseName + type.charAt(0).toUpperCase() + type.slice(1);
    if (propertyName in obj && obj[propertyName] !== undefined) {
      presentChoices.push(type);
    }
  }

  // Validate exactly one choice is present
  if (presentChoices.length === 0) {
    errors.push({
      message: \`Choice field '\${baseName}[x]' is missing - exactly one choice must be provided\`,
      path: [],
      code: ValidationErrorCodes.MISSING_CHOICE_VALUE,
      severity: 'error',
      expected: \`one of: \${allowedTypes.join(', ')}\`,
      actual: 'none present',
    });
  } else if (presentChoices.length > 1) {
    errors.push({
      message: \`Multiple choice values present for '\${baseName}[x]' - only one allowed\`,
      path: [],
      code: ValidationErrorCodes.MULTIPLE_CHOICE_VALUES,
      severity: 'error',
      expected: 'exactly one choice',
      actual: \`\${presentChoices.length} choices: \${presentChoices.join(', ')}\`,
    });
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}

/**
 * Composite validator for multiple validation strategies
 */
export class CompositeValidator {
  private validators: ValidatorFunction[] = [];
  private options: ValidatorOptions;

  constructor(options: Partial<ValidatorOptions> = {}) {
    this.options = {
      includeCardinality: true,
      includeTypes: true,
      includeConstraints: true,
      includeInvariants: false,
      validateRequired: true,
      allowAdditional: false,
      strict: false,
      collectMetrics: false,
      maxDepth: 10,
      customRules: [],
      ...options,
    };
  }

  /**
   * Add a validator to the composite
   */
  addValidator(validator: ValidatorFunction): this {
    this.validators.push(validator);
    return this;
  }

  /**
   * Validate using all registered validators
   */
  async validate<T>(value: unknown): Promise<ValidationResult<T>> {
    const results = await Promise.all(
      this.validators.map(v => Promise.resolve(v(value, this.options)))
    );

    const allErrors = results.flatMap(r => r.errors);
    const allWarnings = results.flatMap(r => r.warnings);
    const valid = results.every(r => r.valid) && (this.options.strict ? allWarnings.length === 0 : true);

    // Use the value from the first successful validator
    const successfulResult = results.find(r => r.valid && r.value !== undefined);
    const value = successfulResult?.value;

    return {
      valid,
      value: valid ? value as T : undefined,
      errors: allErrors,
      warnings: allWarnings,
      metrics: this.options.collectMetrics ? this.combineMetrics(results) : undefined,
    };
  }

  private combineMetrics(results: ValidationResult[]): ValidationMetrics {
    return {
      duration: Math.max(...results.map(r => r.metrics?.duration || 0)),
      fieldsValidated: results.reduce((sum, r) => sum + (r.metrics?.fieldsValidated || 0), 0),
      complexity: results.reduce((sum, r) => sum + (r.metrics?.complexity || 0), 0),
    };
  }
}`;
}

/**
 * Generate partial validator for a schema
 */
function generatePartialValidator(
	schema: AnyTypeSchema,
	options: ValidatorGenerationOptions,
): string {
	if (!("identifier" in schema) || !("fields" in schema)) return "";
	
	const validatorName = `validatePartial${schema.identifier.name}`;
	const typeName = schema.identifier.name;
	const jsDoc = options.includeJSDoc ? generatePartialValidatorJSDoc(schema) : '';
	
	return `${jsDoc}
export function ${validatorName}(
  value: unknown,
  options: Partial<ValidatorOptions> = {}
): ValidationResult<Partial<${typeName}>> {
  // Partial validation - don't require all fields
  const partialOptions: Partial<ValidatorOptions> = {
    ...options,
    validateRequired: false, // Don't enforce required fields for partial validation
  };
  
  return validate${typeName}(value, partialOptions) as ValidationResult<Partial<${typeName}>>;
}`;
}

/**
 * Generate assertion function for a schema
 */
function generateAssertionFunction(
	schema: AnyTypeSchema,
	options: ValidatorGenerationOptions,
): string {
	if (!("identifier" in schema)) return "";
	
	const assertName = `assert${schema.identifier.name}`;
	const validatorName = `validate${schema.identifier.name}`;
	const typeName = schema.identifier.name;
	const jsDoc = options.includeJSDoc ? generateAssertionJSDoc(schema) : '';
	
	return `${jsDoc}
export function ${assertName}(
  value: unknown,
  message?: string
): asserts value is ${typeName} {
  const result = ${validatorName}(value);
  
  if (!result.valid) {
    const errorMessages = result.errors.map(e => \`\${ValidationUtils.formatPath(e.path)}: \${e.message}\`).join('; ');
    const finalMessage = message || \`Value is not a valid ${typeName}: \${errorMessages}\`;
    
    const error = new Error(finalMessage) as any;
    error.validationErrors = result.errors;
    error.validationWarnings = result.warnings;
    throw error;
  }
}`;
}

/**
 * Generate JSDoc for validator function
 */
function generateValidatorJSDoc(schema: AnyTypeSchema, options: ValidatorGenerationOptions): string {
	if (!("identifier" in schema)) return "";
	
	const typeName = schema.identifier.name;
	const description = schema.description || `Validates a ${typeName} object`;
	
	return `/**
 * ${description}
 * 
 * @param value - The value to validate
 * @param options - Validation options
 * @returns Validation result with detailed error information
 * 
 * @example
 * const result = validate${typeName}(data);
 * if (result.valid) {
 *   console.log('Valid ${typeName}:', result.value);
 * } else {
 *   console.error('Validation errors:', result.errors);
 * }
 */`;
}

/**
 * Generate JSDoc for partial validator function
 */
function generatePartialValidatorJSDoc(schema: AnyTypeSchema): string {
	if (!("identifier" in schema)) return "";
	
	const typeName = schema.identifier.name;
	
	return `/**
 * Validates a partial ${typeName} object (useful for updates/patches)
 * 
 * @param value - The partial value to validate
 * @param options - Validation options
 * @returns Validation result for partial object
 */`;
}

/**
 * Generate JSDoc for assertion function
 */
function generateAssertionJSDoc(schema: AnyTypeSchema): string {
	if (!("identifier" in schema)) return "";
	
	const typeName = schema.identifier.name;
	
	return `/**
 * Asserts that a value is a valid ${typeName}
 * 
 * @param value - The value to assert
 * @param message - Optional custom error message
 * @throws {Error} If the value is not a valid ${typeName}
 */`;
}

/**
 * Generate composite validator class
 */
function generateCompositeValidatorClass(
	schemas: AnyTypeSchema[],
	options: ValidatorGenerationOptions,
): string {
	const resourceSchemas = schemas.filter(s => s.identifier.kind === "resource");
	
	return `/**
 * Comprehensive FHIR validator with multiple validation strategies
 */
export class FHIRValidator {
  private schemaValidator: SchemaValidator;
  private customRules: ValidationRule[] = [];

  constructor(options: Partial<ValidatorOptions> = {}) {
    this.schemaValidator = new SchemaValidator(options);
    
    // Register all generated validators
    ${resourceSchemas.map(schema => {
      const typeName = schema.identifier.name;
      const validatorName = `validate${typeName}`;
      return `    this.schemaValidator.registerValidator('${typeName}', ${validatorName});`;
    }).join('\n')}
  }

  /**
   * Validate any FHIR resource
   */
  validate<T extends { resourceType: string }>(
    value: unknown,
    options?: Partial<ValidatorOptions>
  ): ValidationResult<T> {
    if (!value || typeof value !== 'object' || !('resourceType' in value)) {
      return {
        valid: false,
        errors: [{
          message: 'Value must be an object with resourceType',
          path: [],
          code: ValidationErrorCodes.INVALID_RESOURCE_TYPE,
          severity: 'error',
        }],
        warnings: [],
      };
    }

    const obj = value as { resourceType: string };
    return this.schemaValidator.validate(obj.resourceType, value, options);
  }

  /**
   * Validate partial resource (for updates)
   */
  validatePartial<T extends { resourceType: string }>(
    value: Partial<T> & { resourceType: string },
    options?: Partial<ValidatorOptions>
  ): ValidationResult<Partial<T>> {
    return this.schemaValidator.validatePartial(value.resourceType, value, options);
  }

  /**
   * Add custom validation rule
   */
  addCustomRule(rule: ValidationRule): this {
    this.customRules.push(rule);
    return this;
  }

  /**
   * Get all supported resource types
   */
  getSupportedResourceTypes(): string[] {
    return [${resourceSchemas.map(s => `'${s.identifier.name}'`).join(', ')}];
  }
}`;
}

/**
 * Generate validator factory function
 */
function generateValidatorFactory(
	schemas: AnyTypeSchema[],
	options: ValidatorGenerationOptions,
): string {
	return `/**
 * Factory function to create validators with custom options
 */
export function createValidator(options: Partial<ValidatorOptions> = {}): FHIRValidator {
  return new FHIRValidator(options);
}

/**
 * Pre-configured strict validator
 */
export const strictValidator = createValidator({
  strict: true,
  validateRequired: true,
  includeCardinality: true,
  includeTypes: true,
  includeConstraints: true,
  allowAdditional: false,
});

/**
 * Pre-configured lenient validator
 */
export const lenientValidator = createValidator({
  strict: false,
  validateRequired: false,
  includeCardinality: false,
  includeTypes: true,
  includeConstraints: false,
  allowAdditional: true,
});

/**
 * Utility function to validate and transform any FHIR resource
 */
export function validateAndTransform<T extends { resourceType: string }>(
  value: unknown,
  validator: FHIRValidator = strictValidator
): T {
  const result = validator.validate<T>(value);
  
  if (!result.valid) {
    const errorMessages = result.errors.map(e => \`\${ValidationUtils.formatPath(e.path)}: \${e.message}\`).join('; ');
    throw new Error(\`Validation failed: \${errorMessages}\`);
  }
  
  return result.value!;
}`;
}

/**
 * Generate file header
 */
function generateValidatorHeader(): string {
	const timestamp = new Date().toISOString();
	
	return `/**
 * FHIR Validation Functions
 * 
 * Auto-generated comprehensive runtime validation functions for FHIR resources and types.
 * Includes type guards, validators, assertion functions, and composite validation strategies.
 * 
 * Features:
 * - Individual resource validators with detailed error reporting
 * - Partial validation for updates and patches
 * - Assertion functions for type narrowing
 * - Composite validation with multiple strategies
 * - Performance metrics and optimization
 * - Custom validation rules support
 * - FHIR-specific constraint validation
 * 
 * Generated at: ${timestamp}
 * 
 * WARNING: This file is auto-generated. Do not modify manually.
 */

/* eslint-disable */`;
}