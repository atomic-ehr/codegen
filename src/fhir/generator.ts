/**
 * FHIR Generator
 *
 * Main FHIR-specific generator that extends the base TypeSchema generator
 * with FHIR-specific functionality for resources, profiles, extensions,
 * value sets, code systems, and operations.
 */

import type {
	CanonicalManager as CanonicalManagerType,
	Config,
} from "@atomic-ehr/fhir-canonical-manager";
import { CanonicalManager } from "@atomic-ehr/fhir-canonical-manager";
import type { FHIRSchema } from "@atomic-ehr/fhirschema";
import { transformFHIRSchemas } from "../typeschema/core/transformer";
import { TypeSchemaGenerator } from "../typeschema/generator";
import type { AnyTypeSchema, PackageInfo } from "../typeschema/lib-types";
import type {
	FHIRGenerationContext,
	FHIRGeneratorOptions,
	FHIRResourceGenerationResult,
	GenerationWarning,
	ResourceDependency,
} from "./types";
import {
	getFHIRComplexTypes,
	getFHIRPrimitiveTypes,
	getFHIRResourceTypes,
	isFHIRResourceType,
} from "./types";

/**
 * Advanced FHIR-specific generator with full FHIR specification support
 */
export class FHIRGenerator {
	private manager: CanonicalManagerType;
	private options: Required<FHIRGeneratorOptions>;
	private generationWarnings: GenerationWarning[] = [];
	private resourceDependencies: Map<string, ResourceDependency[]> = new Map();

	constructor(options: FHIRGeneratorOptions = {}) {
		this.options = {
			includeProfiles: true,
			includeExtensions: true,
			includeValueSets: true,
			includeCodeSystems: true,
			includeOperations: false,
			fhirVersion: "R4",
			verbose: false,
			resourceTypes: [],
			maxDepth: 10,
			...options,
		};
		const config: Config = {
			packages: [],
			workingDir: process.cwd(),
		};
		this.manager = CanonicalManager(config);
	}

	/**
	 * Generate all FHIR types from a package using TypeSchema as primary interface
	 */
	async generateFromPackage(
		packageName: string,
		packageVersion?: string,
	): Promise<AnyTypeSchema[]> {
		if (this.options.verbose) {
			console.log(
				`[FHIR Generator] Loading package: ${packageName}${packageVersion ? `@${packageVersion}` : ""}`,
			);
		}

		// Clear previous state
		this.generationWarnings = [];
		this.resourceDependencies.clear();

		// Use TypeSchemaGenerator to get base TypeSchemas first
		const typeSchemaGenerator = new TypeSchemaGenerator({
			verbose: this.options.verbose,
		});

		const baseSchemas = await typeSchemaGenerator.generateFromPackage(
			packageName,
			packageVersion,
		);

		if (this.options.verbose) {
			console.log(
				`[FHIR Generator] Generated ${baseSchemas.length} base TypeSchemas`,
			);
		}

		const packageInfo: PackageInfo = {
			name: packageName,
			version: packageVersion || "latest",
		};

		return await this.generateFromTypeSchemas(baseSchemas, packageInfo);
	}

	/**
	 * Generate FHIR types from TypeSchemas (primary method)
	 */
	async generateFromTypeSchemas(
		schemas: AnyTypeSchema[],
		packageInfo?: PackageInfo,
	): Promise<AnyTypeSchema[]> {
		const context: FHIRGenerationContext = {
			manager: this.manager,
			packageInfo,
			options: this.options,
			depth: 0,
			identifierCache: new Map(),
			processingProfiles: new Set(),
			processingExtensions: new Set(),
			availableSchemas: schemas,
		};

		const results: AnyTypeSchema[] = [];

		// Filter schemas based on options
		const filteredSchemas = this.filterTypeSchemas(schemas);

		if (this.options.verbose) {
			console.log(
				`[FHIR Generator] Processing ${filteredSchemas.length} filtered TypeSchemas`,
			);
		}

		// Group schemas by type for efficient processing
		const groupedSchemas = this.groupTypeSchemas(filteredSchemas);

		// Process resources, complex types, and primitives (already generated by TypeSchema)
		results.push(...groupedSchemas.resources);
		results.push(...groupedSchemas.complexTypes);
		results.push(...groupedSchemas.primitives);

		// Generate profiles if enabled
		if (this.options.includeProfiles && groupedSchemas.profiles.length > 0) {
			const profileResults = await this.enhanceProfiles(
				groupedSchemas.profiles,
				context,
			);
			results.push(...profileResults);
		}

		// Generate extensions if enabled
		if (
			this.options.includeExtensions &&
			groupedSchemas.extensions.length > 0
		) {
			const extensionResults = await this.enhanceExtensions(
				groupedSchemas.extensions,
				context,
			);
			results.push(...extensionResults);
		}

		// Generate value sets if enabled
		if (this.options.includeValueSets && groupedSchemas.valueSets.length > 0) {
			const valueSetResults = await this.enhanceValueSets(
				groupedSchemas.valueSets,
				context,
			);
			results.push(...valueSetResults);
		}

		// Generate code systems if enabled
		if (
			this.options.includeCodeSystems &&
			groupedSchemas.codeSystems.length > 0
		) {
			const codeSystemResults = await this.enhanceCodeSystems(
				groupedSchemas.codeSystems,
				context,
			);
			results.push(...codeSystemResults);
		}

		// Generate operations if enabled (use raw fhirschema for this)
		if (this.options.includeOperations) {
			const operationResults =
				await this.generateOperationsFromManager(context);
			results.push(...operationResults);
		}

		if (this.options.verbose) {
			console.log(
				`[FHIR Generator] Generated ${results.length} enhanced FHIR type schemas`,
			);
			if (this.generationWarnings.length > 0) {
				console.log(
					`[FHIR Generator] ${this.generationWarnings.length} warnings generated`,
				);
			}
		}

		return results;
	}

	/**
	 * Generate from single FHIR schema with detailed result
	 */
	async generateFromSchemaDetailed(
		schema: FHIRSchema,
		packageInfo?: PackageInfo,
	): Promise<FHIRResourceGenerationResult[]> {
		const context: FHIRGenerationContext = {
			manager: this.manager,
			packageInfo,
			options: this.options,
			depth: 0,
			identifierCache: new Map(),
			processingProfiles: new Set(),
			processingExtensions: new Set(),
		};

		const results: FHIRResourceGenerationResult[] = [];
		const schemas = await transformFHIRSchema(
			schema,
			this.manager,
			packageInfo,
		);

		for (const generatedSchema of schemas) {
			results.push({
				schema: generatedSchema,
				source: schema,
				metadata: {
					resourceType: schema.name || schema.id || "unknown",
					generatedAt: new Date(),
					profilesApplied: [],
					extensionsIncluded: [],
					warnings: [...this.generationWarnings],
				},
			});
		}

		return results;
	}

	/**
	 * Add dependency package for reference resolution using TypeSchemaGenerator
	 */
	async addDependencyPackage(
		packageName: string,
		packageVersion?: string,
	): Promise<void> {
		if (this.options.verbose) {
			console.log(
				`[FHIR Generator] Adding dependency: ${packageName}${packageVersion ? `@${packageVersion}` : ""}`,
			);
		}

		// Use TypeSchemaGenerator to get schemas for dependency package
		const typeSchemaGenerator = new TypeSchemaGenerator({
			verbose: this.options.verbose,
		});

		const schemas = await typeSchemaGenerator.generateFromPackage(
			packageName,
			packageVersion,
		);

		// Register canonical URLs with the manager (if it supports it)
		for (const schema of schemas) {
			if (schema.identifier.url) {
				// Note: CanonicalManager may not have a register method
				// This would depend on the actual implementation
				try {
					// await this.manager.register(schema.identifier.url, schema);
					console.log(`Would register: ${schema.identifier.url}`);
				} catch (error) {
					console.warn(`Could not register ${schema.identifier.url}: ${error}`);
				}
			}
		}
	}

	/**
	 * Get generation warnings
	 */
	getWarnings(): GenerationWarning[] {
		return [...this.generationWarnings];
	}

	/**
	 * Get resource dependencies
	 */
	getResourceDependencies(resourceType?: string): ResourceDependency[] {
		if (resourceType) {
			return this.resourceDependencies.get(resourceType) || [];
		}

		const allDeps: ResourceDependency[] = [];
		for (const deps of this.resourceDependencies.values()) {
			allDeps.push(...deps);
		}
		return allDeps;
	}

	/**
	 * Clear generator state
	 */
	clearCache(): void {
		const config: Config = {
			packages: [],
			workingDir: process.cwd(),
		};
		this.manager = CanonicalManager(config);
		this.generationWarnings = [];
		this.resourceDependencies.clear();
	}

	/**
	 * Update generator options
	 */
	setOptions(options: Partial<FHIRGeneratorOptions>): void {
		this.options = { ...this.options, ...options };
	}

	/**
	 * Get current options
	 */
	getOptions(): FHIRGeneratorOptions {
		return { ...this.options };
	}

	// Private helper methods

	private filterTypeSchemas(schemas: AnyTypeSchema[]): AnyTypeSchema[] {
		let filtered = schemas;

		// Filter by resource types if specified
		if (this.options.resourceTypes.length > 0) {
			filtered = filtered.filter(
				(schema) =>
					!schema.identifier.name ||
					this.options.resourceTypes.includes(schema.identifier.name) ||
					!isFHIRResourceType(schema.identifier.name, schemas),
			);
		}

		return filtered;
	}

	private groupTypeSchemas(schemas: AnyTypeSchema[]): {
		resources: AnyTypeSchema[];
		complexTypes: AnyTypeSchema[];
		primitives: AnyTypeSchema[];
		profiles: AnyTypeSchema[];
		extensions: AnyTypeSchema[];
		valueSets: AnyTypeSchema[];
		codeSystems: AnyTypeSchema[];
	} {
		const groups = {
			resources: [] as AnyTypeSchema[],
			complexTypes: [] as AnyTypeSchema[],
			primitives: [] as AnyTypeSchema[],
			profiles: [] as AnyTypeSchema[],
			extensions: [] as AnyTypeSchema[],
			valueSets: [] as AnyTypeSchema[],
			codeSystems: [] as AnyTypeSchema[],
		};

		for (const schema of schemas) {
			switch (schema.identifier.kind) {
				case "resource":
					groups.resources.push(schema);
					break;
				case "complex-type":
					groups.complexTypes.push(schema);
					break;
				case "primitive-type":
					groups.primitives.push(schema);
					break;
				case "profile":
					groups.profiles.push(schema);
					break;
				case "binding":
					// Extensions are complex-types with special metadata
					if ("metadata" in schema && schema.metadata?.isExtension) {
						groups.extensions.push(schema);
					} else {
						groups.complexTypes.push(schema);
					}
					break;
				case "value-set":
					groups.valueSets.push(schema);
					break;
				default:
					// Check metadata for special types
					if ("metadata" in schema && schema.metadata?.isCodeSystem) {
						groups.codeSystems.push(schema);
					} else {
						groups.complexTypes.push(schema);
					}
					break;
			}
		}

		return groups;
	}

	// Enhanced generation methods that work with TypeSchemas
	private async enhanceProfiles(
		schemas: AnyTypeSchema[],
		context: FHIRGenerationContext,
	): Promise<AnyTypeSchema[]> {
		// Profiles are already generated by TypeSchema transformer
		// Add any FHIR-specific enhancements here
		return schemas;
	}

	private async enhanceExtensions(
		schemas: AnyTypeSchema[],
		context: FHIRGenerationContext,
	): Promise<AnyTypeSchema[]> {
		// Extensions are already generated by TypeSchema transformer
		// Add any FHIR-specific enhancements here
		return schemas;
	}

	private async enhanceValueSets(
		schemas: AnyTypeSchema[],
		context: FHIRGenerationContext,
	): Promise<AnyTypeSchema[]> {
		// ValueSets are already generated by TypeSchema transformer
		// Add any FHIR-specific enhancements here
		return schemas;
	}

	private async enhanceCodeSystems(
		schemas: AnyTypeSchema[],
		context: FHIRGenerationContext,
	): Promise<AnyTypeSchema[]> {
		// CodeSystems are already generated by TypeSchema transformer
		// Add any FHIR-specific enhancements here
		return schemas;
	}

	private async generateOperationsFromManager(
		context: FHIRGenerationContext,
	): Promise<AnyTypeSchema[]> {
		// Use CanonicalManager to search for OperationDefinitions
		try {
			const operationResources = await context.manager.search({
				type: "OperationDefinition",
			});

			// Convert to FHIRSchemas and then to TypeSchemas
			const fhirSchemas: FHIRSchema[] = operationResources.map((resource) => ({
				url: resource.url || "",
				name: resource.id,
				type: "OperationDefinition",
				kind: "operation",
				class: "OperationDefinition",
				description: resource.description,
				package_name: context.packageInfo?.name,
				package_version: context.packageInfo?.version,
				elements: {},
			}));

			return await transformFHIRSchemas(
				fhirSchemas,
				context.manager,
				context.packageInfo,
			);
		} catch (error) {
			console.warn(`Failed to generate operations: ${error}`);
			return [];
		}
	}

	private addWarning(warning: GenerationWarning): void {
		this.generationWarnings.push(warning);

		if (this.options.verbose && warning.severity === "high") {
			console.warn(
				`[FHIR Generator] Warning: ${warning.message}${warning.path ? ` at ${warning.path}` : ""}`,
			);
		}
	}

	private addResourceDependency(
		resourceType: string,
		dependency: ResourceDependency,
	): void {
		if (!this.resourceDependencies.has(resourceType)) {
			this.resourceDependencies.set(resourceType, []);
		}
		this.resourceDependencies.get(resourceType)!.push(dependency);
	}
}

/**
 * Convenience function to generate FHIR types from a package
 */
export async function generateFHIRFromPackage(
	packageName: string,
	options: FHIRGeneratorOptions = {},
	packageVersion?: string,
): Promise<AnyTypeSchema[]> {
	const generator = new FHIRGenerator(options);
	return await generator.generateFromPackage(packageName, packageVersion);
}

/**
 * Convenience function to generate FHIR types from TypeSchemas
 */
export async function generateFHIRFromTypeSchemas(
	schemas: AnyTypeSchema[],
	packageInfo?: PackageInfo,
	options: FHIRGeneratorOptions = {},
): Promise<AnyTypeSchema[]> {
	const generator = new FHIRGenerator(options);
	return await generator.generateFromTypeSchemas(schemas, packageInfo);
}
